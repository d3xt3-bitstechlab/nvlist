
Next free ticket:
LVN-011

Currently working on:
LVN-004

--- Framework ------------------------------------------------------------------

[x] LVN-005 - Some Parts need an update/tick method
  - Decide how to implement an update/tick methods. Is that just an optional interface that all parts are allowed to implement? For example, ITextRenderer
    needs an explicit update() function that's called every frame. Make sure ButtonDrawable calls the textrenderer update method.
[x] LVN-006 - Call update() on all Parts for all Entities
  - Screen.update(), with the entities in timestamp order?
[ ] LVN-007 - BasicPartRegistry contains implementation details
  - BasicPartRegistry should not define specific implementation classes, it should only use public interfaces. This means there needs to be a subclass or PartRegistry builder somewhere that initializes the registry with the specific implementation classes.
[ ] LVN-010 - bug: Part.update() is called multiple times
  - Part.update() is called once for each PartType the part object is used for. Instead, the update function should be called once per frame. Perhaps this is easiest if I explicitly implement a way of traversing all parts inside game-entity.
  
    
--- Input handling -------------------------------------------------------------

[ ] LVN-004 - Design an interface for user input handling
  - Information from IDrawablePart is necessary to determine if a click lies inside the visual bounds of the entity. Layer bounds and visibility should also be considered. Determining to which drawables to pass input information is largely similar to determining which drawables should be rendered.
  - If clipEnabled is false, also process input outside the bounds of the drawable's parent layer.
  - Input handling should be done in reverse Z-order from rendering, and the input object should be passed to the top-most drawables first.
  - Example visibility calculation code in LightNVL1:
    boolean visibleEnough = isVisible(alphaEnableThreshold);
    boolean inputHeld = isInputHeld(input);
    boolean contains = (!isClipEnabled() || layer.containsRel(x, y))
        && contains(x, y) && visibleEnough;
    [x] Do I want to use IDrawablePart to determine the touch area, then forward to inputhandlers attached to the drawable, or do I want a separate inputhandler part that Layer calls after determining visibility and the coordinate system through drawable?
      - Use an inputhandler part. I want to be able to guarantee a certain order of input handling. Other parts are then allowed to be registered as listeners with the input handler part. Linking the parts together is done when the entity is created. This method makes it slightly more annoying to dynamically add/remove parts with input handling at runtime, but that's not something I plan on doing much of. The input handler part could potentially listen to part detach events of its listeners.

--- Drawables ------------------------------------------------------------------
 
[ ] LVN-001 - Add a way to perform custom rendering for IDrawableParts
  - Currently, code external to the entity determines its rendering. I would like to give text/buttons their own custom rendering code. To do this, I need to add an overridable draw() method to IDrawablePart.
  - I don't want Drawable to know ImagePart, but ImagePart itself doesn't know about rendering. What I basically need is a subclass of Drawable that -does- know about ImagePart. The most straightforward solution I see is to turn my current ImagePart into a non-part helper class and then implement an ImageDrawable extends Transformable that uses a delegate imagehelper object.

--- Buttons --------------------------------------------------------------------

[ ] LVN-002 - Implement buttons
    [ ] LVN-003 - Implement click-handling for buttons -- scheduling an IScriptFunction on the ScriptEventDispatcher.	

--- Save support ---------------------------------------------------------------

[ ] LVN-008 - Encoding of save file thumbnails
  - The thumbnail image should be stored as a separate file inside the save .zip archive. These zip entries should be stored uncompressed.
[ ] LVN-009 - Determine save format of persistent storage
  - Persistent variables are saved in their own special file. This file's format is different from a normal save file. Should I just store the data as XML?
  - Store a schemaVersion attribute in the header to be able to distinguish between (incompatible) saves made by different engine versions.
    
--------------------------------------------------------------------------------

[ ] Integrate EDT functionality.
    [ ] As long as the textbox task knows which context it wants to block, I can just call
        myContext:getMainThread():setMinWait(1) from Lua to block the main thread for a frame.

[ ] Current *State objects such as ImageState should be Scene-global. In what
    way do I want to support something like that? Do I maybe want Service
    objects that are attached to a Scene? Service is kind of a generic term,
    so I should think of a more uncommon name.
    [ ] List of Scene-related state:
      - imageState (including layers)
      - soundState
      - videoState
      - Lua threads
      - (textState) really only the current textDrawable. Speed/textlog is
        global.
      - background image, image layer
        I'll want a Lua-accessible object for storing scene-specific state in.
        Maybe just a LuaTable that's assignable from the script (scene.state)?
      + Everything else is global/service/factory.

--------------------------------------------------------------------------------

[ ] Add preload support to image/sound modules.
[ ] Stuff I need for scripting:
  - Initialize standard library/objects
  - EDT
  - Save/load
[ ] Context lifecycle
  - Root context is non-destructible (how to mark different?)
  - How does the user create/suspend/destroy contexts
  
[ ] How to implement scripting:
    [ ] Do I have a single global main thread, or does each scene have its own?
      - Having a single main thread is convenient when multiple contexts can be active at the same time.
        Otherwise, on which context's main thread would you run the events? Unless every case where I need to
        run Lua code can be definitively associated with exactly 1 context?
    [ ] How to implement standard behavior that's currently being done inside
        vnTask? It's ugly but functional, so I could just keep it for now and
        improve it at some later time?
    [ ] How to implement mode-switching as Scene-switching?
    [ ] How to attach Lua properties and code to an Entity?
      - Attach a LuaPart named "code" that functions as a LuaTable.
      - I could support DanmakuTime-style event hooks: update()/onDestroyed()
    [ ] There should be an annotation that signifies which classes are accessible through script functions.
    [ ] Wrapping LuaExceptions in ScriptExceptions creates very long exception chains.
    [ ] Support for assertions in Lua code?

[ ] Write unit tests for the pile of code I've written recently.
    [ ] DrawBuffer
    [ ] Renderer
    [ ] ScriptEventDispatcher

[ ] Ensure the eventThread in LuaScriptContext is always empty at the end of each update.
[ ] Move utility methods from BaseImpl to somewhere more appropriate.
[ ] Allow registering custom hooks in my Lua<->Java bridge so I can do automatic
    conversion from Rect/Vec2 to tables.
    I'm doing some other method-specific data conversions in my get/set property
    function within Lua that should also ideally be arranged on the Java level.

  